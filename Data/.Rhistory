if( B[b] == nex){
b = b + 1
ci <- ci + length(A) - a
} else {
a = a + 1
}
}
A
B
A = sort(c(11,5,15,10))
B = sort(c(12,2,13,1))
a  <- 1
b  <- 1
ci <- 0
outlist <- c()
while( a < length(A) + 1  && b < length(B) +1 ) {
nex <- min(A[a],B[b])
print(paste0("a",a))
print(paste0("b",b))
outlist <- c(outlist,nex)
print(outlist)
if( B[b] == nex){
b = b + 1
ci <- ci + length(A) - a
} else {
a = a + 1
}
}
ci
A = sort(c(11,5,15,10))
B = sort(c(12,2,13,1))
a  <- 1
b  <- 1
ci <- 0
outlist <- c()
while( a < (length(A) + 1)  && b < length(B) +1 ) {
nex <- min(A[a],B[b])
print(paste0("a",a))
print(paste0("b",b))
outlist <- c(outlist,nex)
print(outlist)
if( B[b] == nex){
b = b + 1
ci <- ci + length(A) - a
} else {
a = a + 1
}
}
ci
A
B
A = sort(c(11,5,15,10))
B = sort(c(12,2,13,1))
a  <- 1
b  <- 1
ci <- 0
outlist <- c()
while( a < (length(A) + 1)  && b < length(B) +1 ) {
nex <- min(A[a],B[b])
print(paste0("a",a))
print(paste0("b",b))
outlist <- c(outlist,nex)
print(outlist)
if( B[b] == nex){
b = b + 1
temp <- length(A) - a
ci <- ci + temp
} else {
a = a + 1
}
}
A = sort(c(11,5,15,10))
B = sort(c(12,2,13,1))
a  <- 1
b  <- 1
ci <- 0
outlist <- c()
while( a < (length(A) + 1)  && b < length(B) +1 ) {
nex <- min(A[a],B[b])
print(paste0("a",a))
print(paste0("b",b))
outlist <- c(outlist,nex)
print(outlist)
if( B[b] == nex){
b = b + 1
temp <- length(A) - a
ci <- ci + temp
print(temp)
} else {
a = a + 1
}
}
count.inversion(A)
count.inversion(B)
count.inversion(c(A,B))
A = sort(c(11,5,15,10))
B = sort(c(12,2,13,1))
a  <- 1
b  <- 1
ci <- 0
outlist <- c()
while( a < (length(A) + 1)  && b < length(B) +1 ) {
nex <- min(A[a],B[b])
print(paste0("a",a))
print(paste0("b",b))
outlist <- c(outlist,nex)
print(outlist)
if( B[b] == nex){
b = b + 1
temp <- length(b) - b
ci <- ci + temp
print(temp)
} else {
a = a + 1
}
}
ci
A = sort(c(11,5,15,10))
B = sort(c(12,2,13,1))
a  <- 1
b  <- 1
ci <- 0
outlist <- c()
while( a < (length(A) + 1)  && b < length(B) +1 ) {
nex <- min(A[a],B[b])
print(paste0("a",a))
print(paste0("b",b))
outlist <- c(outlist,nex)
print(outlist)
if( B[b] == nex){
b = b + 1
temp <- length(b) + b
ci <- ci + temp
print(temp)
} else {
a = a + 1
}
}
ci
A = sort(c(11,5,15,10))
B = sort(c(12,2,13,1))
a  <- 1
b  <- 1
ci <- 0
outlist <- c()
while( a < (length(A) + 1)  && b < length(B) +1 ) {
nex <- min(A[a],B[b])
print(paste0("a",a))
print(paste0("b",b))
outlist <- c(outlist,nex)
print(outlist)
if( B[b] == nex){
b = b + 1
temp <- length(A) - a
ci <- ci + temp
print(temp)
} else {
a = a + 1
}
}
ci
A = sort(c(11,5,15,10))
B = sort(c(12,2,13,1))
a  <- 1
b  <- 1
ci <- 0
outlist <- c()
while( a < (length(A) + 1)  && b < length(B) +1 ) {
nex <- min(A[a],B[b])
print(paste0("a",a))
print(paste0("b",b))
outlist <- c(outlist,nex)
print(outlist)
if( B[b] == nex){
b = b + 1
print(temp)
} else {
a = a + 1
temp <- length(A) - a
ci <- ci + temp
}
}
c
ci
A = sort(c(11,5,15,10))
B = sort(c(12,2,13,1))
a  <- 1
b  <- 1
ci <- 0
outlist <- c()
while( a < (length(A) + 1)  && b < length(B) +1 ) {
nex <- min(A[a],B[b])
print(paste0("a",a))
print(paste0("b",b))
outlist <- c(outlist,nex)
print(outlist)
if( B[b] == nex){
b = b + 1
temp <- length(A) - a
ci <- ci + temp
} else {
a = a + 1
}
}
ci
A = sort(c(11,5,15,10))
B = sort(c(12,2,13,1))
a  <- 1
b  <- 1
ci <- 0
outlist <- c()
while( a < (length(A) + 1)  && b < length(B) +1 ) {
nex <- min(A[a],B[b])
print(paste0("a",a))
print(paste0("b",b))
outlist <- c(outlist,nex)
print(outlist)
if( B[b] == nex){
b = b + 1
temp <- length(A)
ci <- ci + temp
} else {
a = a + 1
}
}
ci
A = sort(c(11,5,15,10))
B = sort(c(12,2,13,1))
a  <- 1
b  <- 1
ci <- 0
outlist <- c()
while( a < (length(A) + 1)  && b < length(B) +1 ) {
nex <- min(A[a],B[b])
print(paste0("a",a))
print(paste0("b",b))
outlist <- c(outlist,nex)
print(outlist)
if( B[b] == nex){
b = b + 1
temp <- length(A) -b
ci <- ci + temp
} else {
a = a + 1
}
}
ci
A = sort(c(11,5,15,10))
B = sort(c(12,2,13,1))
a  <- 1
b  <- 1
ci <- 0
outlist <- c()
while( a < (length(A) + 1)  && b < length(B) +1 ) {
nex <- min(A[a],B[b])
print(paste0("a",a))
print(paste0("b",b))
outlist <- c(outlist,nex)
print(outlist)
if( B[b] == nex){
b = b + 1
temp <- length(A) - a + 1
ci <- ci + temp
} else {
a = a + 1
}
}
ci
A = c(11,5,15,10)
B = c(12,2,13,1)
count.inversion(A)
count.inversion(B)
count.inversion(c(A,B))
ms <- function(L) {
if( length(L) == 2){ return(c( min(L), max(L) ) ) } else {
L1 <- ms(L[1:length(L)/2])
L2 <- ms(L[length(L)/2+1:length(L)])
return(c(L1,L2))
}
}
A
ms(c(A,B))
c(A,b)
c(A,B)
unif(1000)
runif(1000)
runif(10000)/10000
sum(runif(10000))/10000
### data ~ t(3)
loglik.fun <- function(x,theta){
n   <- length(x)
nth <- length(theta)
loglik <- rep(0,nth)
for(i in 1:n){
loglik <- loglik + log(dt(x[i]-theta,3))
}
loglik <- loglik - max(loglik)
loglik
}
n <- 2
x <- rt(n,3)
a <- max(abs(x))
m <- 10000
theta <- seq(-6,6,length=m)
loglik <- loglik.fun(x,theta)
lik <-  exp(loglik)
post <- exp(loglik)
delta <- theta[2]-theta[1]
post <- post/(delta*sum(post))
normalpost <- dnorm(theta,mean(x),1/sqrt(n))
b <- max(c(post,normalpost))
par(mfrow=c(1,1),pty="s")
plot(theta,post,type="l",lwd=3,xlab="theta",ylab="f(theta | data)",ylim=c(0,b))
lines(theta,normalpost,lwd=1,lty=2,col=2)
postmean <- delta*sum(theta*post)
print(postmean)
### N(xbar,1/n) importance sampler
nsim <- 10000
THETA <- rnorm(nsim, mean(x),1/sqrt(n))
lik <- exp(loglik.fun(x,THETA))
g   <-  dnorm(THETA,mean(x),1/sqrt(n))
estimate <- mean(THETA*lik/g)/mean(lik/g)
print(estimate)
### Cauchy importance sampler
THETA <- rcauchy(nsim, mean(x))
lik <- exp(loglik.fun(x,THETA))
g   <-  dcauchy(THETA,mean(x))
estimate <- mean(THETA*lik/g)/mean(lik/g)
print(estimate)
gibbs.fun = function(y,n,N){
k     = length(y)
p.hat = y/n
Z     = log(p.hat/(1-p.hat))
sigma = sqrt(1/(n*p.hat*(1-p.hat)))
v     = 1/sqrt(k)
mu    = rep(0,N)
psi   = matrix(0,N,k)
for(i in 2:N){
### draw mu given rest
b     = mean(psi[i-1,])
mu[i] = rnorm(1,b,v)
### draw psi given rest
e       = ( (Z/sigma^2) + mu[i])/(1 + (1/sigma^2))
d       = sqrt(1/(1 + (1/sigma^2)))
psi[i,] = rnorm(k,e,d)
}
list(mu=mu,psi=psi)
}
k = 40
p = rbeta(k,5,5)
n = rep(20,k)
y = rbinom(k,n,p)
print(y/n)
N = 1000
out = gibbs.fun(y,n,N)
#postscript("gibbs1.eps",horizontal=F,onefile=F,print.it=F)
par(mfrow=c(2,1))
p  =  exp(out$psi)/(1+exp(out$psi))
mu = out$mu
plot(1:N,p[,1],type="l",xlab="",ylab="",xaxt="n",yaxt="n",bty="l",ylim=c(0,1))
axis(1,c(0,500,1000),cex.axis=2);axis(2,c(0,0.5,1.0),cex.axis=2)
plot(1:N,mu,type="l",xlab="",ylab="",xaxt="n",yaxt="n",bty="l",
ylim=c(-.5,.5))
axis(1,c(0,500,1000),cex.axis=2);axis(2,c(-0.5,0,0.5),cex.axis=2)
#dev.off()
n = rep(5,k)
y = rbinom(k,n,p)
print(y/n)
N = 1000
out = gibbs.fun(y,n,N)
#postscript("gibbs1.eps",horizontal=F,onefile=F,print.it=F)
par(mfrow=c(2,1))
p  =  exp(out$psi)/(1+exp(out$psi))
mu = out$mu
plot(1:N,p[,1],type="l",xlab="",ylab="",xaxt="n",yaxt="n",bty="l",ylim=c(0,1))
axis(1,c(0,500,1000),cex.axis=2);axis(2,c(0,0.5,1.0),cex.axis=2)
plot(1:N,mu,type="l",xlab="",ylab="",xaxt="n",yaxt="n",bty="l",
ylim=c(-.5,.5))
axis(1,c(0,500,1000),cex.axis=2);axis(2,c(-0.5,0,0.5),cex.axis=2)
#dev.off()
plot(1:N,p[,1],type="l",xlab="",ylab="",xaxt="n",yaxt="n",bty="l",ylim=c(0,1))
axis(1,c(0,500,1000),cex.axis=2);axis(2,c(0,0.5,1.0),cex.axis=2)
plot(1:N,mu,type="l",xlab="",ylab="",xaxt="n",yaxt="n",bty="l",
ylim=c(-.5,.5))
axis(1,c(0,500,1000),cex.axis=2);axis(2,c(-0.5,0,0.5),cex.axis=2)
k = 40
p = rbeta(k,5,5)
n = rep(30,k)
y = rbinom(k,n,p)
print(y/n)
N = 1000
out = gibbs.fun(y,n,N)
#postscript("gibbs1.eps",horizontal=F,onefile=F,print.it=F)
par(mfrow=c(2,1))
p  =  exp(out$psi)/(1+exp(out$psi))
mu = out$mu
plot(1:N,p[,1],type="l",xlab="",ylab="",xaxt="n",yaxt="n",bty="l",ylim=c(0,1))
axis(1,c(0,500,1000),cex.axis=2);axis(2,c(0,0.5,1.0),cex.axis=2)
plot(1:N,mu,type="l",xlab="",ylab="",xaxt="n",yaxt="n",bty="l",
ylim=c(-.5,.5))
axis(1,c(0,500,1000),cex.axis=2);axis(2,c(-0.5,0,0.5),cex.axis=2)
###################################################################################################
### Project - Group 7
###################################################################################################
# Author:   Felix Gutmann
#           Max van Esso
#           Marco Fayet
# Course:   Deterministic Models and Optimization
# Due:      11.12.2015
# Type:     Project - Topic 1
# Content:  Naive and Divide & Conquer Algorithms to count inversions in an input array
###################################################################################################
#### START CODE # START CODE # START CODE # START CODE # START CODE # START CODE # START CODE #####
###################################################################################################
# Clear workspace
rm( list = ls() )
# Set working directory
setwd("/home/felix/Dropbox/GSE/Project group/Deterministic models/Data/")
# Load data
uf <- as.numeric(scan("Permutation.txt",what="",sep=","))
###################################################################################################
### 1. Naive algorithm
###################################################################################################
Naive.count.inversion <- function(A){
# Define legnth of input Array
N <- length(A)
# Initialize the inversion counter
inv.count <- 0
for( i in 1:(N-1) ){
# Define temporary element of A
temp <- A[i]
for( j in  (i+1):N ){
# Compare elements to the right of temp
if( temp > A[j] ) {inv.count <- inv.count + 1}
}
}
# Return the total number of inversions
return(inv.count)
}
###################################################################################################
### 2. Divide and conquer algorithm
###################################################################################################
DC.count.inversion <- function(A){
# Initialize sort and count function
sort.and.count <- function(A){
# Get length of the input array
N <- length(A)
# Base case for length of input equals one
if( length(A) == 1 ){
# Return vector and inversion zero
return( list( array = A , inversion = 0 ) )
# Case if input has length greater than one
} else {
# Define left and right array
mid <- ceiling(N/2)
# Apply recursive call of sort.and.count function for sub lists
sc1 <- sort.and.count( A[ 1:mid ] )
sc2 <- sort.and.count( A[ (mid+1):N ] )
# Merge and count cross inversions
mc  <- count.and.merge( sc1$array , sc2$array )
# Count the total number of inversions
inv.count <- sc1$inversion + sc2$inversion + mc$inversion
# Return sorted array and total inversion count
return(list( array = mc$array , inversion = inv.count ))
}
}
# Initialize count and merge function
count.and.merge <- function(res.a,res.b){
# Initialize empty output list
result  <- c()
# Initialize count variable
cross.count <- 0
# set iterators
a <- 1
b <- 1
# Find inversions
while( a < length(res.a) + 1  && b < length(res.b) + 1 ) {
# Check element a of first array vs. element b in second array
app     <- min(res.a[a],res.b[b])
# Append result to output list
result  <- c(result,app)
# Case 1: element b of second array was appended
if( res.b[b] == app ){
# Update cross inversion count
temp  <- length(res.a) - a + 1
cross.count   <- cross.count + temp
# Update iterator b
b = b + 1
# Case 2: element a of first array was appended
} else {
# Update iterator a
a = a + 1
}
}
# Design final output - Append non empty list
if( a > b ) {
result <- c(result, res.b[b:length(res.b)])
} else {
result <- c(result, res.a[a:length(res.a)])
}
# Return inversions and sorted vector
return(list( array=result, inversion=cross.count) )
}
# Execute function and store results
res <- sort.and.count(A)
# Return final output
return(list( array = res$array, inversion = res$inversion))
}
###################################################################################################
###### END CODE # END CODE # END CODE # END CODE # END CODE # END CODE # END CODE # END CODE ######
###################################################################################################
DC.count.inversion(c(10,2,13))
